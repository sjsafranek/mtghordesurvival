<html>
    <head><meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta http-equiv="X-UA-Compatible" content="ie=edge">
        <title>Mtg Deck Builder</title>
        <link rel="stylesheet" href="static/bootstrap/bootstrap.min.css">
        <link rel="stylesheet" href="static/toastr/toastr.min.css" />

        <style>

            .mtgcard {
                margin: 1px;
                border: 4px solid #ffffff;
                border-radius: 8px;
                transition: border-color 0.3s linear;
            }

            .mtgcard.selected {
                border-color: #0088cc !important;
            }

            .zoneButton {
                cursor: pointer;
                transition: color 0.3s linear;
            }

            .zoneButton:hover {
                color: #0088cc !important;
            }


            /* Sticky footer styles
                https://getbootstrap.com/docs/4.1/examples/sticky-footer/sticky-footer.css
            -------------------------------------------------- */
            html {
                position: relative;
                min-height: 100%;
            }
            body {
                margin-bottom: 60px; /* Margin bottom by footer height */
            }
            .footer {
                position: absolute;
                bottom: 0;
                width: 100%;
                height: 60px; /* Set the fixed height of the footer here */
                line-height: 60px; /* Vertically center the text there */
                /*background-color: #f5f5f5;*/
            }
            /* .end */

            .footer {
                font-size: 10px;
            }



            /*
             * Sidebar
             */

            .sidebar {
              position: fixed;
              top: 0;
              bottom: 0;
              right: 0;
              padding-top: 48px;
              padding-bottom: 48px;
              z-index: 10;
              box-shadow: inset -1px 0 0 rgba(0, 0, 0, .1);
            }

            .sidebar-sticky {
              position: relative;
              top: 0;
              /*height: calc(100vh - 48px);*/
              height: calc(100vh - 96px);
              padding-top: .5rem;
              /*overflow-x: scroll;*/
              overflow-y: auto;
            }




            #gameLog {
                font: 0.6rem Inconsolata, monospace;
                padding-left: 12px;
                padding-right: 12px;
            }


            /*#log {
                background-color: black;
                background-image: radial-gradient(
                    rgba(0, 150, 0, 0.75), black 120%
                );
                height: 100vh;
            }*/




        </style>

    </head>
    <body>

        <div class="container-fluid">
            <div class="row">

                <main role="main" class="col-md-9">

                    <div class="row">
                        <div class="col-md-12">
                            <h4 class="mt-5">Horde Survival</h4>
                            <button id="addZombie" class="btn btn-sm btn-danger ml-2" title="Add Zombie">
                                <i class="fas fa-plus"></i>
                            </button>
                            <button id="takeTurn" class="btn btn-sm btn-primary ml-2" title="Take Turn">
                                <i class="fas fa-forward"></i>
                            </button>
                        </div>
                    </div>

                    <div class="row">
                        <div class="col-md-2">
                            <label><i class="fas fa-eye zoneButton zoneHand"></i> Hand: </label><span class="handCount"></span>
                        </div>
                        <div class="col-md-2">
                            <label><i class="fas fa-eye zoneButton zoneBattlefield"></i> Battlefield: </label><span class="battlefieldCount"></span>
                        </div>
                        <div class="col-md-2">
                            <label><i class="fas fa-eye zoneButton zoneLibrary"></i> Library: </label><span class="libraryCount"></span>
                        </div>
                        <div class="col-md-2">
                            <label><i class="fas fa-eye zoneButton zoneGraveyard"></i> Graveyard: </label><span class="graveyardCount"></span>
                        </div>
                        <div class="col-md-2">
                            <label><i class="fas fa-eye zoneButton zoneExile"></i> Exile: </label><span class="exileCount"></span>
                        </div>
                    </div>

                    <div class="row">
                        <div class="col-md-12 battlefield">
                        </div>
                        <!-- <div class="col-md-3" id="log"></div> -->
                    </div>

                    <div id="card_container"></div>

                </main>

                <nav class="col-md-3 d-none d-md-block bg-light sidebar">
                    <div class="sidebar-sticky">
                        <div id="gameLog">
                        </div>
                    </div>
                </nav>

            </div>
        </div>


        <footer class="footer bg-light">
          <div class="container">
            <span class="text-muted">
                This project uses the <a href="https://scryfall.com/docs/api">ScryFall api</a>.
                Deck list and rules can be found
                <a href="https://www.quietspeculation.com/2011/09/horde-magic-a-new-way-to-play-magic-and-survive-zombie-invasions/">here</a>.
            </span>
          </div>
        </footer>


        <script src="static/d3/d3.min.js"></script>
        <script src="static/jquery/jquery.min.js"></script>
        <script src="static/bootstrap/bootstrap.min.js"></script>
        <script src="static/sweetalert2/sweetalert2.min.js"></script>
        <script src="static/toastr/toastr.min.js"></script>
        <script src="https://kit.fontawesome.com/131ba7f97d.js"></script>
        <script src="static/underscore/underscore-min.js"></script>
        <script src="static/backbone/backbone-min.js"></script>
        <script src="static/backbone/backbone.localStorage-min.js" type="text/javascript">

        <script type="text/template" id="card_template">
            <div class="card">
                <img></img>
            </div>
        </script>

        <script>

localStorage.clear();


var zombie;



var Card = Backbone.Model.extend({
    // Override for scryfall 'id' field.
    // Backbone will use this attribute to make models singletons.
    idAttribute: "_id",
    defaults: {},
    initialize: function(){},
    getName: function() {
        return this.get('name');
    },
    getTypes: function() {
        return this.get('type_line');
    },
    isType: function(cardType) {
        return -1 != this.getTypes()
                        .toLowerCase()
                        .indexOf(cardType.toLowerCase());
    },
    isPermanent: function() {
        const cardTypes = [
            'Artifact',
            'Creature',
            'Enchantment',
            'Land',
            'Planeswalker'
        ];
        for (var i=0; i<cardTypes.length; i++) {
            if (this.isType(cardTypes[i])) {
                return true;
            }
        }
        return false;
    },
    getImage: function(size) {
        return this.get('image_uris')[size||'small'];
    }
});


var Zone = Backbone.Collection.extend({
    model: Card,
    localStorage: new Store("mtghordesurvival"),
    chooseRandom: function() {
        var idx = Math.round(Math.random() * this.length);
        return this.models[idx];
    }
});


var CardView = Backbone.View.extend({
    initialize: function(){
        this.render();
    },
    render: function(){
        // Compile the template using underscore
        this.template = _.template( $("#card_template").html(), {} );
        // Load the compiled HTML into the Backbone "el"
        this.$el.append(this.template);
        this.$el.find('img').attr('src', this.model.getImage());
    }
});



toastr.options = {
    "closeButton": true,
    "newestOnTop": true,
    "timeOut": 2000
};

function toast(level, message) {
    // toastr[level](message).attr('style', 'height: 38px !important; width: 240px !important; vertical-align: middle; padding-top: 10px; font-size: small;');
    var $elem = $('<div>').append(
        new Date().toISOString().split('.')[0],
        ': ',
        message,
    );
    $('#gameLog').append($elem);
    $elem.get(0).scrollIntoView();
}


var Player = function() {
    var self = this;

    this.zones = {
        exile: new Zone(),
        graveyard: new Zone(),
        library: new Zone(),
        hand: new Zone(),
        battlefield: new Zone(),
        stack: new Zone(),
        command: new Zone()
    }

    // TODO
    //  - Fix callbacks for Backbone Model
    this._callbacks = {
        "Grave Titan": function() {
            // etb create two tokens
            self.resolveSpell(zombie);
            self.resolveSpell(zombie);
        },
        "Damnation": function() {
            // destroy all creatures
            self.boardWipe('graveyard', 'Creature');
        },
        "Army of the Damned": function() {
            // create 13 zombies
            for (var i=0; i<13; i++) {
                self.resolveSpell(zombie);
            }

            // has flashback
            var cards = self.zones.graveyard.filter(function(card) {
                return "Army of the Damned" == card.getName();
            });

            for (var i=0; i<cards.length; i++) {
                var card = cards[i];
                self.zones.graveyard.remove(card);
                self.castSpell(card, function(){
                    self.zones.graveyard.remove(card);
                    self.zones.exile.add(card);
                });
            }
            //.end

            self.updateCounts();
        },
        "Twilight's Call": function() {
            // all creatures from graveyard to battlefield
            var cards = self.getCardsByType('creature', 'graveyard');
            for (var i=0; i<cards.length; i++) {
                var card = cards[i];
                self.zones.graveyard.remove(card);
                self.resolveSpell(card);
            }
            self.updateCounts();
        }
    }

    this.updateCounts();
    this.addListeners();
}

Player.prototype.addListeners = function() {
    var self = this;

    var collectOptions = function(zone) {
        var inputOptions = {};
        zone.forEach(function(card) {
            inputOptions[card.cid] = card.getName();
        });
        return inputOptions;
    }

    var selectCardFromZone = function(zone) {
        return {
            title: 'Select a card',
            input: 'select',
            inputOptions: collectOptions(zone),
            inputPlaceholder: 'Select a card',
            showCancelButton: true
        };
    }

    var selectAndChangeCardZone = function(zone) {
        Swal.queue([
            selectCardFromZone(zone),
            {
                title: 'Select zone',
                input: 'select',
                inputOptions: {
                    exile: 'exile',
                    graveyard: 'graveyard',
                    library: 'library',
                    hand: 'hand'
                },
                inputPlaceholder: 'Select a zone',
                showCancelButton: true
            }
        ]).then(function(result){
            if (result.value) {
                var cid = result.value[0];
                var newZone = result.value[1];
                var card = zone.get(cid);
                zone.remove(card);
                self.zones[newZone].add(card);
                self.updateCounts();
            }
        });
    }

    $('.zoneHand').on('click', function(e) {
        selectAndChangeCardZone(self.zones.hand);
    });

    $('.zoneLibrary').on('click', function(e) {
        selectAndChangeCardZone(self.zones.library);
    });

    $('.zoneGraveyard').on('click', function(e) {
        selectAndChangeCardZone(self.zones.graveyard);
    });

    $('.zoneExile').on('click', function(e) {
        selectAndChangeCardZone(self.zones.exile);
    });

    $('.zoneBattlefield').on('click', function(e) {
        selectAndChangeCardZone(self.zones.battlefield);
    });


}

Player.prototype.updateCounts = function() {
    $('.handCount').text(this.zones.hand.length);
    $('.libraryCount').text(this.zones.library.length);
    $('.graveyardCount').text(this.zones.graveyard.length);
    $('.exileCount').text(this.zones.exile.length);
    $('.battlefieldCount').text(this.zones.battlefield.length);
}

Player.prototype.takeTurn = function() {
    if (!this.zones.library.length) {
        $('#draw').addClass('disabled');
        return;
    }

    var card = this.drawCard();
    while(-1 != ['Zombie', 'Zombie Giant'].indexOf(card.getName())) {
        card = this.drawCard();
    }

    this.castSpells();
}

Player.prototype.drawCard = function() {
    if (!this.zones.library.length) {
        toast('warning', 'No cards in library!');
        return;
    }
    toast('success', 'Draw a card');
    var card = this.zones.library.chooseRandom();
    this.zones.library.remove(card);
    this.zones.hand.add(card);
    this.updateCounts();
    return card;
}

Player.prototype.castSpells = function() {
    var self = this;
    // cast all spells from hand
    if (this.zones.hand.length) {
        var card = this.zones.hand.shift();
        this.castSpell(card, function() {
            self.castSpells();
        });
    }

    this.updateCounts();
}

Player.prototype.getCardsByName = function(cardName, zone) {
    zone = zone || 'library';
    return this.zones[zone].filter(function(card) {
        return cardName == card.getName();
    });
}

Player.prototype.getCardsByType = function(cardType, zone) {
    zone = zone || 'library';
    return this.zones[zone].filter(function(card) {
        return card.isType(cardType);
    });
}

Player.prototype.castSpell = function(card, callback) {
    var self = this;

    toast('info', 'Cast ' + card.getName());

    Swal.fire({
        title: card.getName(),
        imageUrl: card.getImage('normal'),
        showCancelButton: true,
        focusConfirm: false,
        confirmButtonText: 'Resolve',
        cancelButtonText: 'Cancel',
        animation: false
    }).then(function(result){
        if (!result.value) {
            self.zones.graveyard.push(card);
            callback && callback();
            return;
        }

        self.resolveSpell(card, callback);
    });
}

Player.prototype.boardWipe = function(zone, cardType) {
    $('.mtgcard').trigger('change_zone', {zone: zone || 'graveyard', cardType: cardType});
}

Player.prototype.resolveSpell = function(card, callback) {
    var self = this;

    toast('success', card.getName() + ' resolved');

    if (card.isPermanent()) {
        this.zones.battlefield.add(card);
        $('.battlefield').append(
            $('<img>', {src: card.getImage()})
                .addClass('mtgcard')
                .on('contextmenu', function(e) {
                    e.preventDefault();
                    Swal.fire({
                        title: 'Select zone',
                        input: 'select',
                        inputOptions: {
                            exile: 'exile',
                            graveyard: 'graveyard',
                            library: 'library',
                            hand: 'hand'
                        },
                        inputPlaceholder: 'Select a zone',
                        showCancelButton: true
                    }).then(function(result) {
                        var zone = result.value;
                        if (zone) {
                            var $elems = $('.mtgcard.selected');
                            if ($elems.length) {
                                $elems.trigger('change_zone', {zone: zone});
                                return;
                            }

                            $(e.target).remove();
                            self.zones.battlefield.remove(card)
                            self.zones[zone].add(card);
                        }
                    });
                }).on('click', function(e){
                    $(e.target).toggleClass('selected');
                }).on('change_zone', function(e, args){
                    if (args.cardType && !card.isType(args.cardType)) {
                        return;
                    }
                    toast('info', card.getName() + " was put into " + args.zone + " from the battlefield.");
                    self.zones.battlefield.remove(card);
                    self.zones[args.zone].add(card);
                    $(this).remove();
                    self.updateCounts();
                })
        );
    } else {
        this.zones.graveyard.add(card);
    }

    callback && callback();

    this._callbacks[card.getName()] && this._callbacks[card.getName()]();
}




// Build deck
var data = 'count,name\n1,Call to the Grave\n2,Bad Moon\n1,Plague Wind\n1,Damnation\n1,Yixlid Jailer\n1,Forsaken Wastes\n2,Nested Ghoul\n2,Infectious Horror\n2,Delirium Skeins\n1,Blind Creeper\n2,Soulless One\n2,Vengeful Dead\n1,Fleshbag Marauder\n1,Carrion Wurm\n3,Maggot Carrier\n4,Cackling Fiend\n1,Death Baron\n1,Grave Titan\n2,Severed Legion\n1,Skulking Knight\n1,Undead Warchief\n1,Twilights Call\n1,Army of the Damned\n1,Endless Ranks of the Dead\n2,Rotting Fensnake\n1,Unbreathing Horde\n1,Walking Corpse\n5,Zombie Giant\n55,Zombie';

function fetchCard(card_name, callback) {
    $.ajax({
        method: 'GET',
        url: 'https://api.scryfall.com/cards/named?exact=' + card_name,
    }).done(callback)
}

var player = new Player();

d3.csvParse(data, function(d) {
    fetchCard(d.name, function(card) {
        if ('Zombie' == card.name) {
            zombie = new Card(card);
        }
        for (var i=0; i<parseInt(d.count); i++) {
            player.zones.library.create(card);
        }
        player.updateCounts();
    });
});













$('#takeTurn').on('click', function(e) {
    player.takeTurn();
});

$('#addZombie').on('click', function(e) {
    player.resolveSpell(zombie);
});


        </script>

    </body>
</html>

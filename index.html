<html>
    <head><meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta http-equiv="X-UA-Compatible" content="ie=edge">
        <title>Mtg Deck Builder</title>
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">
        <link href="https://cdnjs.cloudflare.com/ajax/libs/select2/4.0.6-rc.0/css/select2.min.css" rel="stylesheet" />
        <!-- <link rel="stylesheet" href="https://code.jquery.com/ui/1.12.1/themes/smoothness/jquery-ui.css"> -->
        <link href="https://cdnjs.cloudflare.com/ajax/libs/toastr.js/latest/css/toastr.min.css" rel="stylesheet" />

        <style>

            .mtgcard {
                margin: 1px;
                border: 4px solid #ffffff;
                border-radius: 8px;
                transition: border-color 0.3s linear;
            }

            .mtgcard.selected {
                border-color: #0088cc !important;
            }

        </style>

    </head>
    <body>
        <main role="main" class="container">

            This project uses the ScryFall api (https://scryfall.com/docs/api)

            <div class="row">
                <div class="col-md-12">
                    <h4 class="mt-5">Horde Survival</h4>
                    <button id="addZombie" class="btn btn-sm btn-danger ml-2" title="Add Zombie">
                        <i class="fas fa-plus"></i>
                    </button>
                    <button id="takeTurn" class="btn btn-sm btn-primary ml-2" title="Take Turn">
                        <i class="fas fa-forward"></i>
                    </button>
                </div>
            </div>

            <div class="row">
                <div class="col-md-3">
                    <label>Hand: </label><span class="hand"></span>
                </div>
                <div class="col-md-3">
                    <label>Library: </label><span class="library"></span>
                </div>
                <div class="col-md-3">
                    <label>Graveyard: </label><span class="graveyard"></span>
                </div>
                <div class="col-md-3">
                    <label>Exile: </label><span class="exile"></span>
                </div>
            </div>

            <div class="row">
                <div class="col-md-12 battlefield">
                </div>
            </div>

        </main>

        <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/5.9.2/d3.min.js"></script>
        <script src="https://code.jquery.com/jquery-3.2.1.min.js"></script>
        <!-- <script src="https://code.jquery.com/ui/1.12.1/jquery-ui.js"></script> -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q" crossorigin="anonymous"></script>
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"></script>
        <script src="https://cdn.jsdelivr.net/npm/sweetalert2@8"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/toastr.js/latest/js/toastr.min.js"></script>
        <script src="https://kit.fontawesome.com/131ba7f97d.js"></script>


        <script>


var zombie;

//
// var Stack = function() {
//     this.dataStore = [];
//     this.top = 0;
// }
//
// Stack.prototype.push = function(card) {
//     this.dataStore[this.top++] = card;
// }
//
// Stack.prototype.pop = function() {
//     return this.dataStore[--this.top];
// }
//
// Stack.prototype.peek = function() {
//     return this.dataStore[this.top-1];
// }
//
// Stack.prototype.length = function() {
//     return this.top;
// }
//
// Stack.prototype,clear = function() {
//     this.top = 0;
// }
//
//



toastr.options = {
    "closeButton": true,
    "newestOnTop": true,
    "timeOut": 2000
};




var Player = function(library) {
    var self = this;

    this.zones = {
        exile: [],
        graveyard: [],
        library: library || [],
        hand: [],
        battlefield: {},
        stack: [],
        command: []
    }

    this._idx = 0;

    this._callbacks = {
        "Grave Titan": function() {
            // etb create two tokens
            self.resolveSpell(zombie);
            self.resolveSpell(zombie);
        },
        "Damnation": function() {
            // destroy all creatures
            self.boardWipe('graveyard', 'Creature');
        },
        "Army of the Damned": function() {
            // create 13 zombies
            for (var i=0; i<13; i++) {
                self.resolveSpell(zombie);
            }

            // has flashback
            if (self.zones.graveyard.length && 'Army of the Damned' == self.zones.graveyard[self.zones.graveyard.length-1].name) {
                var card = self.zones.graveyard.pop();
                self.castSpell(card, function(){
                    if (self.zones.graveyard.length && 'Army of the Damned' == self.zones.graveyard[self.zones.graveyard.length-1].name) {
                        var card = self.zones.graveyard.pop();
                        self.zones.exile.push(card);
                    }
                });
            }
        },
        "Twilight's Call": function() {
            // all creatures from graveyard to battlefield
            var noncreatures = [];
            while(self.zones.graveyard.length) {
                var card = self.zones.graveyard.shift();
                if (-1 != card.type_line.indexOf('Creature')) {
                    self.resolveSpell(card);
                } else {
                    noncreatures.push(card);
                }
            }

            // put noncreatures spells back into graveyard
            while(noncreatures.length) {
                var card = noncreatures.shift();
                self.zones.graveyard.push(card);
            }
        }
    }

    this.updateCounts();
}

Player.prototype.updateCounts = function() {
    $('.hand').text(this.zones.hand.length);
    $('.library').text(this.zones.library.length);
    $('.graveyard').text(this.zones.graveyard.length);
    $('.exile').text(this.zones.exile.length);
}

Player.prototype.takeTurn = function() {
    if (!this.zones.library.length) {
        $('#draw').addClass('disabled');
        return;
    }

    this.drawCard();
    var newCard = this.zones.hand[this.zones.hand.length-1];
    while(-1 != ['Zombie', 'Zombie Giant'].indexOf(newCard.name)) {
        this.drawCard();
        var newCard = this.zones.hand[this.zones.hand.length-1];
    }

    this.castSpells();
}

Player.prototype.drawCard = function() {
    if (!this.zones.library.length) {
        toastr.warning("No cards in library!");
        return;
    }

    toastr.success("Drew a card");

    // draw card from 'library' and put into 'hand'
    var card = this.zones.library.shift();
    this.zones.hand.push(card);

    this.updateCounts();
}

Player.prototype.castSpells = function() {
    var self = this;
    // cast all spells from hand
    if (this.zones.hand.length) {
        var card = this.zones.hand.shift();
        this.castSpell(card, function() {
            self.castSpells();
        });
    }

    this.updateCounts();
}

Player.prototype.castSpell = function(card, callback) {
    var self = this;

    toastr.info("Cast " + card.name);

    Swal.fire({
        title: card.name,
        imageUrl: card.image_uris.normal,
        showCancelButton: true,
        focusConfirm: false,
        confirmButtonText: 'Resolve',
        cancelButtonText: 'Cancel',
        animation: false
    }).then(function(result){
        if (!result.value) {
            self.zones.graveyard.push(card);
            callback && callback();
            return;
        }

        self.resolveSpell(card, callback);
    });
}

Player.prototype.boardWipe = function(zone, cardType) {
    $('.mtgcard').trigger('change_zone', {zone: zone || 'graveyard', cardType: cardType});
}

Player.prototype.resolveSpell = function(card, callback) {
    var self = this;

    toastr.success(card.name + " resolved");

    if ('Sorcery' != card.type_line && 'Instant' != card.type_line) {
        this._idx++;
        var idx = 0+this._idx;
        this.zones.battlefield[idx] = card;

        $('.battlefield').append(
            $('<img>', {src: card.image_uris.small})
                .addClass('mtgcard')
                .on('contextmenu', function(e) {
                    e.preventDefault();
                    Swal.fire({
                        title: 'Select zone',
                        input: 'select',
                        inputOptions: {
                            exile: 'exile',
                            graveyard: 'graveyard',
                            library: 'library',
                            hand: 'hand'
                        },
                        inputPlaceholder: 'Select a zone',
                        showCancelButton: true
                    }).then(function(result) {
                        var zone = result.value;
                        if (zone) {
                            var $elems = $('.mtgcard.selected');
                            if ($elems.length) {
                                $elems.trigger('change_zone', {zone: zone});
                                return;
                            }

                            $(e.target).remove();
                            delete self.zones.battlefield[idx];
                            self.zones[zone].push(card);
                        }
                    });
                }).on('click', function(e){
                    $(e.target).toggleClass('selected');
                }).on('change_zone', function(e, args){
                    if (args.cardType && -1 == card.type_line.indexOf(args.cardType)) {
                        return;
                    }

                    toastr.info(card.name + " was put into " + args.zone + " from the battlefield.");

                    delete self.zones.battlefield[idx];
                    self.zones[args.zone].push(card);
                    $(this).remove();

                    self.updateCounts();
                })
        );
    } else {
        this.zones.graveyard.push(card);
    }

    callback && callback();

    this._callbacks[card.name] && this._callbacks[card.name]();
}




// Build deck
var data = 'count,name\n1,Call to the Grave\n2,Bad Moon\n1,Plague Wind\n1,Damnation\n1,Yixlid Jailer\n1,Forsaken Wastes\n2,Nested Ghoul\n2,Infectious Horror\n2,Delirium Skeins\n1,Blind Creeper\n2,Soulless One\n2,Vengeful Dead\n1,Fleshbag Marauder\n1,Carrion Wurm\n3,Maggot Carrier\n4,Cackling Fiend\n1,Death Baron\n1,Grave Titan\n2,Severed Legion\n1,Skulking Knight\n1,Undead Warchief\n1,Twilights Call\n1,Army of the Damned\n1,Endless Ranks of the Dead\n2,Rotting Fensnake\n1,Unbreathing Horde\n1,Walking Corpse\n5,Zombie Giant\n55,Zombie';

function fetchCard(card_name, callback) {
    $.ajax({
        method: 'GET',
        url: 'https://api.scryfall.com/cards/named?exact=' + card_name,
    }).done(callback)
}

var deck = [];
d3.csvParse(data, function(d) {
    fetchCard(d.name, function(card) {
        var count = parseInt(d.count);
        for (var i=0; i<count; i++) {
            deck.push(card);
            if ('Zombie' == card.name) {
                zombie = card;
            }
            deck = d3.shuffle(deck);
        }
    });
});



var player = new Player(deck);







$('#takeTurn').on('click', function(e) {
    player.takeTurn();
});

$('#addZombie').on('click', function(e) {
    player.resolveSpell(zombie);
});


        </script>

    </body>
</html>
